#!/usr/bin/env bash
{ set +x; } 2>/dev/null

# usage: requirements.txt path
IFS=
[[ $# == 0 ]] || [[ $1 == "--help" ]] && {
	cat <<EOF && exit 1
usage: ${BASH_SOURCE[0]##*/} path
EOF
}
txt=~/.python_lib.txt
! [ -e "$txt" ] && echo "ERROR: $txt NOT EXISTS
re-install package" && exit 1
! [ -s "$txt" ] && echo "ERROR: $txt EMPTY
re-install package" && exit 1

# sort by longest to shortest (grep exact match first)
#python_lib="$(cat "$txt" | sort -r)" || exit

function requirements() {
	{ set +x; } 2>/dev/null
	# 1) import pkgname as alias, pkgname2 as alias2  
	local file="$1"
	grep="$(cat "$1" | awk '{$1=$1};1' | grep ^"import ")"
	[[ -n "$grep" ]] && {
		import="$(while IFS= read l; do
			IFS=' ';set -- $l;IFS=
			shift
			[[ "$@" == *"#"* ]] && { # comment? 
				IFS='#';set -- "$@";IFS= # split by #
				set -- "$1" # before # comment
			}
			IFS=',';set "$@";IFS=
			while (($#)); do
				[[ -n $1 ]] && ( IFS=.;set $1;echo $1 | tr , '\n')
				# import pkgname as alias
				[[ $2 == "as" ]] && shift 3 && continue
				shift
			done
		done <<< "$grep")"
	}
	# 2) # from pkgname.modname import *
	grep="$(cat "$1" | awk '{$1=$1};1' | grep ^"from ")"
	[[ -n "$grep" ]] && {
		from="$(while IFS= read l; do
			IFS=' ';set $l;IFS=
			shift
			( IFS=.;set $1;echo $1)
		done <<< "$grep")"
	}
	[[ -n "$import" ]] || [[ -n "$from" ]] && {
		( echo "$import"; echo "$from" ) | while read r; do
			[[ -z $r ]] && continue
			[[ $r == ".."* ]] && continue
			[ -e "${file%/*}"/"$r".py ] && continue
			# english, digit and _
			[[ $r =~ ^[A-Za-z_0-9]+$ ]] || continue
			echo "$r"
		done
	}
	:
}

[ -z "$1" ] && echo "ERROR: \$1 '' EMPTY" && exit 1
! [ -e "$1" ] && echo "ERROR: $1 NOT EXISTS" && exit 1
path="$1"
# exclude parent path
#IFS=/;set $path;IFS=
#path_exclude="$(while :; do
	#IFS=/;set $path
	#[[ -n ${1%%.*} ]] && echo ${1%%.*}
	#shift
	##path="$*"
	#[[ $# == 0 ]] && break
#done)"

[ -d "$path" ] && {
	exclude="/build/
/dist/"
	find="$(find "$path" -type f -name "*.py" ! -regex '.*/\..*' | grep -v "$exclude")" || exit
	# python -m py_compile "$f" || exit # validate python file
	requirements="$(while IFS= read f; do
		requirements "$f"
	done <<< "$find")"
}
[ -f "$path" ] && {
	# python -m py_compile "$1" || exit # validate python file
	[[ $path == *"/build/"* ]] && exit 0
	[[ $path == *"/dist/"* ]] && exit 0
	requirements="$(requirements "$path")"
}


# sort by longest to shortest
requirements="$(echo "$requirements" | sort -r -u)"

[[ -n $path_exclude ]] && {
	requirements="$(echo "$requirements" | grep -Fx -v "$path_exclude")"
}

# 'future' package installs python3 modules for python2
future="_dummy_thread
_markupbase
builtins
configparser
copyreg
html
libfuturize
libpasteurize
queue
past
reprlib
tkinter
winreg
xmlrpc"

grep_future="$(echo "$requirements" | grep -Fx "$future")"

requirements="$(echo "$requirements" | grep -Fx -f ~/.python_lib.txt -v)"

[[ -n $grep_future ]] && requirements="$requirements
future"

requirements="$(echo "$requirements" | grep -v ^$ | sort -u)"
[[ -n "$requirements" ]] && echo "$requirements";:
